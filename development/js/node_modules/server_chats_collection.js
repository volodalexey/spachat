var Server_chat_model = require('./server_chat_model');

var Server_chat_collection = function(options) {
    this.chatsById = {};
    this.generateAttempts = 100;
};

Server_chat_collection.prototype = {

    __class_name: "server_chat_collection",
    // TODO use client side module {{
    s4: function() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    },

    s4Date: function() {
        return Date.now().toString(16).substring(1);
    },

    generateId: function() {
        return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' +
            this.s4() + '-' + this.s4() + this.s4() + this.s4Date();
    },
    // TODO use client side module }}

    sendError: function(currentWebSocketConnection, error, parsedMessageData) {
        console.log(error);
        var strErr = JSON.stringify({
            message: error.toString(),
            type: "error",
            chat_description: parsedMessageData.chat_description
        });
        currentWebSocketConnection.send(JSON.stringify(strErr));
    },

    checkIfExist: function(newChatData) {
        var _this = this;
        return _this.chatsById[newChatData.chat_description.chatId];
    },

    checkOrGenerateChatId: function(options, callback) {
        var _this = this;
        if (_this.checkIfExist(options.messageData)) {
            if (options.currentAttempt < options.generateAttempts) {
                console.log('Try to generate chat new id, old chat id : ', options.messageData.chat_description.chatId);
                options.messageData.chat_description.chatId = _this.generateId();
                console.log('New chat id : ', options.messageData.chat_description.chatId);
                options.currentAttempt++;
                return _this.checkOrGenerateChatId(options, callback);
            }

            return new Error('Unable to generate new chat id!');
        }

        return options.messageData;
    },

    applyDeviceId: function(currentWebSocketConnection, parsedMessageData) {
        currentWebSocketConnection.deviceId = parsedMessageData.deviceId;
        currentWebSocketConnection.tempDeviceId = parsedMessageData.tempDeviceId;
    },

    /**
     * device requested to create new chat
     * server should check chat id for its uniqueness among other server stored chats
     * store current web socket connection and notify requested device with chat description
     * @param currentWebSocketConnection
     * @param parsedMessageData
     */
    onDeviceCreateChat: function(currentWebSocketConnection, parsedMessageData) {
        var _this = this, originalChatId = parsedMessageData.chat_description.chatId;
        var correctedClientChatData = _this.checkOrGenerateChatId({
            messageData: parsedMessageData,
            currentAttempt: 0,
            generateAttempts: _this.generateAttempts
        });

        if (correctedClientChatData && correctedClientChatData instanceof Error) {
            _this.sendError(currentWebSocketConnection, correctedClientChatData, parsedMessageData);
            return;
        }

        var serverStoredChat = _this.checkIfExist(correctedClientChatData);
        if (!serverStoredChat) {
            serverStoredChat = _this.storeNewChat(correctedClientChatData.chat_description);
        }

        _this.applyDeviceId(currentWebSocketConnection, parsedMessageData);
        if (!parsedMessageData.deviceId && !parsedMessageData.tempDeviceId) {
            currentWebSocketConnection.tempDeviceId = _this.generateId(); // temp device id until the device send offer
        }
        serverStoredChat.storeWebSocketConnection(currentWebSocketConnection);
        var responseData = {
            type: 'chat_created',
            userId: parsedMessageData.userId,
            originalChatId: originalChatId,
            tempDeviceId: currentWebSocketConnection.tempDeviceId,
            deviceId: currentWebSocketConnection.deviceId,
            chat_description: serverStoredChat.toChatDescription()
        };

        currentWebSocketConnection.send(JSON.stringify(responseData));

        console.log('Create chat from',
            'deviceId = ' + currentWebSocketConnection.deviceId,
            'tempDeviceId = ' + currentWebSocketConnection.tempDeviceId,
            'userId = ' + correctedClientChatData.userId,
            'chatId = ' + correctedClientChatData.chat_description.chatId);
    },

    storeNewChat: function(chat_description) {
        var _this = this;
        return _this.chatsById[chat_description.chatId] = new Server_chat_model(chat_description);
    },

    onDeviceChatJoin: function(currentWebSocketConnection, parsedMessageData) {
        var _this = this;
        var serverStoredChat = _this.checkIfExist(parsedMessageData);
        if (!serverStoredChat) {
            serverStoredChat = _this.storeNewChat(parsedMessageData.chat_description);
        }

        _this.applyDeviceId(currentWebSocketConnection, parsedMessageData);
        serverStoredChat.storeWebSocketConnection(currentWebSocketConnection);

        var responseData = {
            type: 'chat_joined',
            userId: parsedMessageData.userId,
            tempDeviceId: currentWebSocketConnection.tempDeviceId,
            deviceId: currentWebSocketConnection.deviceId,
            connectedDevices: serverStoredChat.getAllWebSocketsConnections(),
            chat_description: serverStoredChat.toChatDescription()
        };

        serverStoredChat.broadcastMessage(JSON.stringify(responseData));

        console.log('Join chat from',
            'deviceId = ' + currentWebSocketConnection.deviceId,
            'tempDeviceId = ' + currentWebSocketConnection.tempDeviceId,
            'userId = ' + responseData.userId,
            'chatId = ' + responseData.chat_description.chatId);
    },

    /**
     * device created offer
     * server stores this device and its offer
     * and notifies all other clients in this chat
     * @param currentWebSocketConnection
     * @param parsedMessageData
     */
    onDeviceChatOffer: function(currentWebSocketConnection, parsedMessageData) {
        var _this = this, serverStoredChat = _this.checkIfExist(parsedMessageData);
        if (!serverStoredChat) {
            console.log(new Error('Created offer for chat that is not stored previously on the server'));
            serverStoredChat = _this.storeNewChat(parsedMessageData.chat_description);
        }

        _this.applyDeviceId(currentWebSocketConnection, parsedMessageData);
        serverStoredChat.storeWebSocketConnection(currentWebSocketConnection);

        var toWebSocketConnection = serverStoredChat.getConnection(parsedMessageData.toDevice);
        if (!toWebSocketConnection) {
            _this.sendError(currentWebSocketConnection, new Error('Target connection is not found!'), parsedMessageData);
            return;
        }

        var responseData = {
            type: 'notifyChat',
            notify_data: 'serverStoredOffer',
            deviceId: currentWebSocketConnection.deviceId,
            userId: parsedMessageData.userId,
            offerDescription: parsedMessageData.offerDescription,
            toDevice: toWebSocketConnection.getAllConnectionDeviceId(),
            chat_description: serverStoredChat.toChatDescription()
        };

        toWebSocketConnection.send(JSON.stringify(responseData));

        console.log(
            'Offer from',
            'deviceId = ' + currentWebSocketConnection.deviceId,
            'to deviceId = ' + toWebSocketConnection.deviceId,
            'to tempDeviceId = ' + toWebSocketConnection.tempDeviceId,
            'userId = ' + responseData.userId,
            'chatId = ' + responseData.chat_description.chatId);
    },

    /**
     * device created answer for offer
     * notify only the device that created offer
     */
    onDeviceChatAnswer: function(currentWebSocketConnection, parsedMessageData) {
        var _this = this, serverStoredChat = _this.checkIfExist(parsedMessageData);
        if (!serverStoredChat) {
            console.log(new Error('Created answer for chat that is not stored previously on the server'));
            serverStoredChat = _this.storeNewChat(parsedMessageData.chat_description);
        }

        _this.applyDeviceId(currentWebSocketConnection, parsedMessageData);
        serverStoredChat.storeWebSocketConnection(currentWebSocketConnection);

        var toWebSocketConnection = serverStoredChat.getConnection(parsedMessageData.toDevice);
        if (!toWebSocketConnection) {
            _this.sendError(currentWebSocketConnection, new Error('Target connection is not found!'), parsedMessageData);
            return;
        }

        var responseData = {
            type: 'notifyChat',
            notify_data: 'serverStoredAnswer',
            deviceId: currentWebSocketConnection.deviceId,
            userId: parsedMessageData.userId,
            toDevice: toWebSocketConnection.getAllConnectionDeviceId(),
            answerDescription: parsedMessageData.answerDescription,
            chat_description: serverStoredChat.toChatDescription()
        };

        toWebSocketConnection.send(JSON.stringify(responseData));

        console.log(
            'Answer from',
            'deviceId = ' + responseData.deviceId,
            'to deviceId = ' + toWebSocketConnection.deviceId,
            'to tempDeviceId = ' + toWebSocketConnection.tempDeviceId,
            'userId = ' + responseData.userId,
            'chatId = ' + responseData.chat_description.chatId);
    },

    /**
     * device accepted answer
     * peer-to-peer connection has to be established between devices
     * remove all connection data between them except offers
     */
    onDeviceChatAccept: function(currentWebSocketConnection, parsedMessageData) {
        var _this = this, serverStoredChat = _this.checkIfExist(parsedMessageData);
        if (!serverStoredChat) {
            console.log(new Error('Created answer for chat that is not stored previously on the server'));
            serverStoredChat = _this.storeNewChat(parsedMessageData.chat_description);
        }

        _this.applyDeviceId(currentWebSocketConnection, parsedMessageData);
        serverStoredChat.storeWebSocketConnection(currentWebSocketConnection);

        var toWebSocketConnection = serverStoredChat.getConnection(parsedMessageData.toDevice);
        if (!toWebSocketConnection) {
            _this.sendError(currentWebSocketConnection, new Error('Target connection is not found!'), parsedMessageData);
            return;
        }

        var responseData = {
            type: 'notifyChat',
            notify_data: 'serverStoredAnswer',
            deviceId: parsedMessageData.deviceId,
            userId: parsedMessageData.userId,
            toDevice: toWebSocketConnection.getAllConnectionDeviceId(),
            chat_description: serverStoredChat.toChatDescription()
        };

        toWebSocketConnection.send(JSON.stringify(responseData));

        console.log(
            'Accept from',
            'deviceId = ' + responseData.deviceId,
            'to deviceId = ' + toWebSocketConnection.deviceId,
            'to tempDeviceId = ' + toWebSocketConnection.tempDeviceId,
            'userId = ' + responseData.userId,
            'chatId = ' + responseData.chat_description.chatId);
    }
};

module.exports = Server_chat_collection;